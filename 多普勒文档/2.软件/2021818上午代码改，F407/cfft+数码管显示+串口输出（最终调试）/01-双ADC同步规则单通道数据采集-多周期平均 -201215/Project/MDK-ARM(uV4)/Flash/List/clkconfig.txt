; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\clkconfig.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\clkconfig.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\..\..\..\ARM\CMSIS\5.7.0\CMSIS\Include -I..\..\User\LED -I..\..\User\systick -I..\..\User -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_LOOPUNROLL -DARM_MATH_CM4 --omf_browse=.\flash\obj\clkconfig.crf ..\..\User\clkconfig.c]
                          THUMB

                          AREA ||i.HSE_SetSysClock||, CODE, READONLY, ALIGN=2

                  HSE_SetSysClock PROC
;;;82     
;;;83     void HSE_SetSysClock(uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;84     {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;85     	
;;;86     	
;;;87     	/* 复位RCC所有寄存器 */
;;;88     	RCC_DeInit();
00000c  f7fffffe          BL       RCC_DeInit
;;;89     	
;;;90     	ErrorStatus HSE_ErrorStatus = ERROR;
000010  f04f0800          MOV      r8,#0
;;;91     	
;;;92     	/* Enable HSE */
;;;93     	/* 使能 HSE */
;;;94     	RCC_HSEConfig(RCC_HSE_ON);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_HSEConfig
;;;95     
;;;96     	/* Wait till HSE is ready */
;;;97     	HSE_ErrorStatus = RCC_WaitForHSEStartUp();
00001a  f7fffffe          BL       RCC_WaitForHSEStartUp
00001e  4680              MOV      r8,r0
;;;98     	
;;;99     	if(HSE_ErrorStatus == SUCCESS)
000020  f1b80f01          CMP      r8,#1
000024  d133              BNE      |L1.142|
;;;100    	{
;;;101    		/* Select regulator voltage output Scale 1 mode */
;;;102    		/* 选择电压调节模式为模式1 */
;;;103    		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000026  481b              LDR      r0,|L1.148|
000028  6800              LDR      r0,[r0,#0]
00002a  f0405080          ORR      r0,r0,#0x10000000
00002e  4919              LDR      r1,|L1.148|
000030  6008              STR      r0,[r1,#0]
;;;104    		PWR->CR |= PWR_CR_VOS;
000032  4819              LDR      r0,|L1.152|
000034  6800              LDR      r0,[r0,#0]
000036  f4404040          ORR      r0,r0,#0xc000
00003a  4917              LDR      r1,|L1.152|
00003c  6008              STR      r0,[r1,#0]
;;;105    		
;;;106            RCC_HCLKConfig(RCC_SYSCLK_Div1);
00003e  2000              MOVS     r0,#0
000040  f7fffffe          BL       RCC_HCLKConfig
;;;107    		RCC_PCLK1Config(RCC_HCLK_Div4);
000044  f44f50a0          MOV      r0,#0x1400
000048  f7fffffe          BL       RCC_PCLK1Config
;;;108    		RCC_PCLK2Config(RCC_HCLK_Div2);
00004c  f44f5080          MOV      r0,#0x1000
000050  f7fffffe          BL       RCC_PCLK2Config
;;;109    
;;;110    		/* Configure the main PLL */
;;;111    		RCC_PLLConfig(RCC_PLLSource_HSE,PLLM,PLLN,PLLP,PLLQ);
000054  4633              MOV      r3,r6
000056  462a              MOV      r2,r5
000058  4621              MOV      r1,r4
00005a  f44f0080          MOV      r0,#0x400000
00005e  9700              STR      r7,[sp,#0]
000060  f7fffffe          BL       RCC_PLLConfig
;;;112    	
;;;113    		/* Enable the main PLL */
;;;114    		RCC_PLLCmd(ENABLE);
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       RCC_PLLCmd
;;;115    		
;;;116    		/* Wait till the main PLL is ready */
;;;117    		while( RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
00006a  bf00              NOP      
                  |L1.108|
00006c  2039              MOVS     r0,#0x39
00006e  f7fffffe          BL       RCC_GetFlagStatus
000072  2800              CMP      r0,#0
000074  d0fa              BEQ      |L1.108|
;;;118    
;;;119    		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
;;;120    		FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
000076  f2407005          MOV      r0,#0x705
00007a  4908              LDR      r1,|L1.156|
00007c  6008              STR      r0,[r1,#0]
;;;121    		
;;;122    		/* Select the main PLL as system clock source */
;;;123    		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
00007e  2002              MOVS     r0,#2
000080  f7fffffe          BL       RCC_SYSCLKConfig
;;;124    		
;;;125    		/* Wait till the main PLL is used as system clock source */
;;;126    	/*	返回值 The clock source used as system clock. The returned value can be one
;;;127    	 *         of the following:
;;;128    	 *              - 0x00: HSI used as system clock
;;;129    	 *              - 0x04: HSE used as system clock
;;;130    	 *              - 0x08: PLL used as system clock (PLL P for STM32F446xx devices)
;;;131    	 *              - 0x0C: PLL R used as system clock (only for STM32F446xx devices)
;;;132    	 */
;;;133    		while( RCC_GetSYSCLKSource() != 0x08);
000084  bf00              NOP      
                  |L1.134|
000086  f7fffffe          BL       RCC_GetSYSCLKSource
00008a  2808              CMP      r0,#8
00008c  d1fb              BNE      |L1.134|
                  |L1.142|
;;;134    		
;;;135    	}
;;;136    	else
;;;137    	{
;;;138    		/* HSE启动失败，在此添加错误处理代码 */
;;;139    	}
;;;140    
;;;141    }
00008e  e8bd83f8          POP      {r3-r9,pc}
;;;142    
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x40023840
                  |L1.152|
                          DCD      0x40007000
                  |L1.156|
                          DCD      0x40023c00

                          AREA ||i.HSI_SetSysClock||, CODE, READONLY, ALIGN=2

                  HSI_SetSysClock PROC
;;;142    
;;;143    void HSI_SetSysClock(uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;144    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;145    	
;;;146    	
;;;147    	/* 复位RCC所有寄存器 */
;;;148    	RCC_DeInit();
00000c  f7fffffe          BL       RCC_DeInit
;;;149    	
;;;150    	volatile uint32_t HSI_ErrorStatus = 0;
000010  2000              MOVS     r0,#0
000012  9001              STR      r0,[sp,#4]
;;;151    	
;;;152    	/* Enable HSI */
;;;153    	/* 使能 HSI */
;;;154    	RCC_HSICmd(ENABLE);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       RCC_HSICmd
;;;155    
;;;156    
;;;157    	/* Wait till HSI is ready */
;;;158    	HSI_ErrorStatus = RCC->CR & RCC_CR_HSIRDY;
00001a  481f              LDR      r0,|L2.152|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0000002          AND      r0,r0,#2
000022  9001              STR      r0,[sp,#4]
;;;159    	
;;;160    	if(HSI_ErrorStatus == RCC_CR_HSIRDY)
000024  9801              LDR      r0,[sp,#4]
000026  2802              CMP      r0,#2
000028  d134              BNE      |L2.148|
;;;161    	{
;;;162    		/* Select regulator voltage output Scale 1 mode */
;;;163    		/* 选择电压调节模式为模式1 */
;;;164    		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
00002a  481b              LDR      r0,|L2.152|
00002c  3040              ADDS     r0,r0,#0x40
00002e  6800              LDR      r0,[r0,#0]
000030  f0405080          ORR      r0,r0,#0x10000000
000034  4918              LDR      r1,|L2.152|
000036  3140              ADDS     r1,r1,#0x40
000038  6008              STR      r0,[r1,#0]
;;;165    		PWR->CR |= PWR_CR_VOS;
00003a  4818              LDR      r0,|L2.156|
00003c  6800              LDR      r0,[r0,#0]
00003e  f4404040          ORR      r0,r0,#0xc000
000042  4916              LDR      r1,|L2.156|
000044  6008              STR      r0,[r1,#0]
;;;166    		
;;;167            RCC_HCLKConfig(RCC_SYSCLK_Div1);
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       RCC_HCLKConfig
;;;168    		RCC_PCLK1Config(RCC_HCLK_Div4);
00004c  f44f50a0          MOV      r0,#0x1400
000050  f7fffffe          BL       RCC_PCLK1Config
;;;169    		RCC_PCLK2Config(RCC_HCLK_Div2);
000054  f44f5080          MOV      r0,#0x1000
000058  f7fffffe          BL       RCC_PCLK2Config
;;;170    
;;;171    		/* Configure the main PLL */
;;;172    		RCC_PLLConfig(RCC_PLLSource_HSI,PLLM,PLLN,PLLP,PLLQ);
00005c  4633              MOV      r3,r6
00005e  462a              MOV      r2,r5
000060  4621              MOV      r1,r4
000062  2000              MOVS     r0,#0
000064  9700              STR      r7,[sp,#0]
000066  f7fffffe          BL       RCC_PLLConfig
;;;173    	
;;;174    		/* Enable the main PLL */
;;;175    		RCC_PLLCmd(ENABLE);
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       RCC_PLLCmd
;;;176    		
;;;177    		/* Wait till the main PLL is ready */
;;;178    		while( RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
000070  bf00              NOP      
                  |L2.114|
000072  2039              MOVS     r0,#0x39
000074  f7fffffe          BL       RCC_GetFlagStatus
000078  2800              CMP      r0,#0
00007a  d0fa              BEQ      |L2.114|
;;;179    
;;;180    		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
;;;181    		FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
00007c  f2407005          MOV      r0,#0x705
000080  4907              LDR      r1,|L2.160|
000082  6008              STR      r0,[r1,#0]
;;;182    		
;;;183    		/* Select the main PLL as system clock source */
;;;184    		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000084  2002              MOVS     r0,#2
000086  f7fffffe          BL       RCC_SYSCLKConfig
;;;185    		
;;;186    		/* Wait till the main PLL is used as system clock source */
;;;187    	/*	返回值 The clock source used as system clock. The returned value can be one
;;;188    	 *         of the following:
;;;189    	 *              - 0x00: HSI used as system clock
;;;190    	 *              - 0x04: HSE used as system clock
;;;191    	 *              - 0x08: PLL used as system clock (PLL P for STM32F446xx devices)
;;;192    	 *              - 0x0C: PLL R used as system clock (only for STM32F446xx devices)
;;;193    	 */
;;;194    		while( RCC_GetSYSCLKSource() != 0x08);
00008a  bf00              NOP      
                  |L2.140|
00008c  f7fffffe          BL       RCC_GetSYSCLKSource
000090  2808              CMP      r0,#8
000092  d1fb              BNE      |L2.140|
                  |L2.148|
;;;195    		
;;;196    	}
;;;197    	else
;;;198    	{
;;;199    		/* HSI启动失败，在此添加错误处理代码 */
;;;200    	}
;;;201    
;;;202    }
000094  e8bd81fc          POP      {r2-r8,pc}
;;;203    
                          ENDP

                  |L2.152|
                          DCD      0x40023800
                  |L2.156|
                          DCD      0x40007000
                  |L2.160|
                          DCD      0x40023c00

                          AREA ||i.User_SetSysClock||, CODE, READONLY, ALIGN=2

                  User_SetSysClock PROC
;;;3      
;;;4      void User_SetSysClock(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;5      {
;;;6      	//复位RCC所有寄存器
;;;7      	RCC_DeInit();
000002  f7fffffe          BL       RCC_DeInit
;;;8      	
;;;9      /******************************************************************************/
;;;10     /*            PLL (clocked by HSE) used as System clock source                */
;;;11     /******************************************************************************/
;;;12     	
;;;13     	__IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
00000a  9000              STR      r0,[sp,#0]
;;;14     	
;;;15       /* Enable HSE */
;;;16     	RCC->CR |= ((uint32_t)RCC_CR_HSEON);
00000c  4834              LDR      r0,|L3.224|
00000e  6800              LDR      r0,[r0,#0]
000010  f4403080          ORR      r0,r0,#0x10000
000014  4932              LDR      r1,|L3.224|
000016  6008              STR      r0,[r1,#0]
;;;17      
;;;18       /* Wait till HSE is ready and if Time out is reached exit */
;;;19     	do
000018  bf00              NOP      
                  |L3.26|
;;;20     	{
;;;21     		HSEStatus = RCC->CR & RCC_CR_HSERDY;
00001a  4831              LDR      r0,|L3.224|
00001c  6800              LDR      r0,[r0,#0]
00001e  f4003000          AND      r0,r0,#0x20000
000022  9000              STR      r0,[sp,#0]
;;;22     		StartUpCounter++;
000024  9801              LDR      r0,[sp,#4]
000026  1c40              ADDS     r0,r0,#1
000028  9001              STR      r0,[sp,#4]
;;;23     	} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
00002a  9800              LDR      r0,[sp,#0]
00002c  b918              CBNZ     r0,|L3.54|
00002e  9801              LDR      r0,[sp,#4]
000030  f5b04fa0          CMP      r0,#0x5000
000034  d1f1              BNE      |L3.26|
                  |L3.54|
;;;24     
;;;25     	if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000036  482a              LDR      r0,|L3.224|
000038  6800              LDR      r0,[r0,#0]
00003a  f4003000          AND      r0,r0,#0x20000
00003e  b110              CBZ      r0,|L3.70|
;;;26     	{
;;;27     		HSEStatus = (uint32_t)0x01;
000040  2001              MOVS     r0,#1
000042  9000              STR      r0,[sp,#0]
000044  e001              B        |L3.74|
                  |L3.70|
;;;28     	}
;;;29     	else
;;;30     	{
;;;31     		HSEStatus = (uint32_t)0x00;
000046  2000              MOVS     r0,#0
000048  9000              STR      r0,[sp,#0]
                  |L3.74|
;;;32     	}
;;;33     
;;;34     	if (HSEStatus == (uint32_t)0x01)
00004a  9800              LDR      r0,[sp,#0]
00004c  2801              CMP      r0,#1
00004e  d146              BNE      |L3.222|
;;;35     	{
;;;36     		/* Select regulator voltage output Scale 1 mode */
;;;37     		RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000050  4823              LDR      r0,|L3.224|
000052  3040              ADDS     r0,r0,#0x40
000054  6800              LDR      r0,[r0,#0]
000056  f0405080          ORR      r0,r0,#0x10000000
00005a  4921              LDR      r1,|L3.224|
00005c  3140              ADDS     r1,r1,#0x40
00005e  6008              STR      r0,[r1,#0]
;;;38     		PWR->CR |= PWR_CR_VOS;
000060  4820              LDR      r0,|L3.228|
000062  6800              LDR      r0,[r0,#0]
000064  f4404040          ORR      r0,r0,#0xc000
000068  491e              LDR      r1,|L3.228|
00006a  6008              STR      r0,[r1,#0]
;;;39     
;;;40     		/* HCLK = SYSCLK / 1*/
;;;41     		RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
00006c  481c              LDR      r0,|L3.224|
00006e  3008              ADDS     r0,r0,#8
000070  6800              LDR      r0,[r0,#0]
000072  491b              LDR      r1,|L3.224|
000074  3108              ADDS     r1,r1,#8
000076  6008              STR      r0,[r1,#0]
;;;42     
;;;43     		/* PCLK2 = HCLK / 2*/
;;;44     		RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
000078  4608              MOV      r0,r1
00007a  6800              LDR      r0,[r0,#0]
00007c  f4404000          ORR      r0,r0,#0x8000
000080  6008              STR      r0,[r1,#0]
;;;45         
;;;46     		/* PCLK1 = HCLK / 4*/
;;;47     		RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
000082  4608              MOV      r0,r1
000084  6800              LDR      r0,[r0,#0]
000086  f44050a0          ORR      r0,r0,#0x1400
00008a  6008              STR      r0,[r1,#0]
;;;48     
;;;49     //----------------------------------------------------------
;;;50     //输    入         : pllm：VCO 输入时钟 分频因子，范围0-63
;;;51     //					 plln：VCO 输出时钟 倍频因子，范围192-432
;;;52     //					 pllp：PLLCLK 时钟分频因子，范围2, 4, 6, or 8
;;;53     //					 pllq：OTG FS,SDIO,RNG 时钟分频因子，范围4-15
;;;54     //下面8是HSE外部时钟8MHz，336是倍频，2是分频，最终达到168MHz。
;;;55     		/* Configure the main PLL */
;;;56     		RCC->PLLCFGR = 8 | (336 << 6) | (((2 >> 1) -1) << 16) |
00008c  4816              LDR      r0,|L3.232|
00008e  1f09              SUBS     r1,r1,#4
000090  6008              STR      r0,[r1,#0]
;;;57     					   (RCC_PLLCFGR_PLLSRC_HSE) | (7 << 24);
;;;58     		
;;;59     		/* Enable the main PLL */
;;;60     		RCC->CR |= RCC_CR_PLLON;
000092  1f08              SUBS     r0,r1,#4
000094  6800              LDR      r0,[r0,#0]
000096  f0407080          ORR      r0,r0,#0x1000000
00009a  1f09              SUBS     r1,r1,#4
00009c  6008              STR      r0,[r1,#0]
;;;61     
;;;62     		/* Wait till the main PLL is ready */
;;;63     		while((RCC->CR & RCC_CR_PLLRDY) == 0);
00009e  bf00              NOP      
                  |L3.160|
0000a0  480f              LDR      r0,|L3.224|
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f0007000          AND      r0,r0,#0x2000000
0000a8  2800              CMP      r0,#0
0000aa  d0f9              BEQ      |L3.160|
;;;64     
;;;65     		/* Configure Flash prefetch, Instruction cache, Data cache and wait state */
;;;66     		FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
0000ac  f2407005          MOV      r0,#0x705
0000b0  490e              LDR      r1,|L3.236|
0000b2  6008              STR      r0,[r1,#0]
;;;67     
;;;68     		/* Select the main PLL as system clock source */
;;;69     		RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
0000b4  480a              LDR      r0,|L3.224|
0000b6  3008              ADDS     r0,r0,#8
0000b8  6800              LDR      r0,[r0,#0]
0000ba  f0200003          BIC      r0,r0,#3
0000be  4908              LDR      r1,|L3.224|
0000c0  3108              ADDS     r1,r1,#8
0000c2  6008              STR      r0,[r1,#0]
;;;70     		RCC->CFGR |= RCC_CFGR_SW_PLL;
0000c4  4608              MOV      r0,r1
0000c6  6800              LDR      r0,[r0,#0]
0000c8  f0400002          ORR      r0,r0,#2
0000cc  6008              STR      r0,[r1,#0]
;;;71     
;;;72     		/* Wait till the main PLL is used as system clock source */
;;;73     		while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
0000ce  bf00              NOP      
                  |L3.208|
0000d0  4803              LDR      r0,|L3.224|
0000d2  3008              ADDS     r0,r0,#8
0000d4  6800              LDR      r0,[r0,#0]
0000d6  f000000c          AND      r0,r0,#0xc
0000da  2808              CMP      r0,#8
0000dc  d1f8              BNE      |L3.208|
                  |L3.222|
;;;74         
;;;75     	  }
;;;76     	  else
;;;77     	  { /* If HSE fails to start-up, the application will have wrong clock
;;;78     			 configuration. User can add here some code to deal with this error */
;;;79     	  }
;;;80     
;;;81     }
0000de  bd1c              POP      {r2-r4,pc}
;;;82     
                          ENDP

                  |L3.224|
                          DCD      0x40023800
                  |L3.228|
                          DCD      0x40007000
                  |L3.232|
                          DCD      0x07405408
                  |L3.236|
                          DCD      0x40023c00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\clkconfig.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_clkconfig_c_38099df5____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_clkconfig_c_38099df5____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_clkconfig_c_38099df5____REVSH|
#line 144
|__asm___11_clkconfig_c_38099df5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_clkconfig_c_38099df5____RRX|
#line 300
|__asm___11_clkconfig_c_38099df5____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
