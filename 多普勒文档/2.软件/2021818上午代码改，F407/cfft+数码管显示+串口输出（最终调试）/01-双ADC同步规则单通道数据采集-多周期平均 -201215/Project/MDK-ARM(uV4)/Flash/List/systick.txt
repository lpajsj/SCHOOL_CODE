; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\systick.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\systick.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\..\..\..\ARM\CMSIS\5.7.0\CMSIS\Include -I..\..\User\LED -I..\..\User\systick -I..\..\User -D__MICROLIB -D__UVISION_VERSION=528 -D_RTE_ -DSTM32F407xx -DUSE_STDPERIPH_DRIVER -DSTM32F40_41xxx -DARM_MATH_LOOPUNROLL -DARM_MATH_CM4 --omf_browse=.\flash\obj\systick.crf ..\..\User\systick\systick.c]
                          THUMB

                          AREA ||i.SysTick_Init||, CODE, READONLY, ALIGN=2

                  SysTick_Init PROC
;;;11     *******************************************************************************/
;;;12     void SysTick_Init(u8 SYSCLK)
000000  b510              PUSH     {r4,lr}
;;;13     {
000002  4604              MOV      r4,r0
;;;14      	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); 
000004  f06f0004          MVN      r0,#4
000008  f7fffffe          BL       SysTick_CLKSourceConfig
;;;15     	fac_us=SYSCLK/8;						//SYSCLK的8分频 保存1us所需的计数次数
00000c  17e1              ASRS     r1,r4,#31
00000e  eb047151          ADD      r1,r4,r1,LSR #29
000012  f3c101c7          UBFX     r1,r1,#3,#8
000016  4a07              LDR      r2,|L1.52|
000018  7011              STRB     r1,[r2,#0]
;;;16     	fac_ms=(u16)fac_us*1000;				//每个ms需要的systick时钟数   
00001a  4610              MOV      r0,r2
00001c  7800              LDRB     r0,[r0,#0]  ; fac_us
00001e  eb000140          ADD      r1,r0,r0,LSL #1
000022  ebc110c0          RSB      r0,r1,r0,LSL #7
000026  f64f71ff          MOV      r1,#0xffff
00002a  ea0100c0          AND      r0,r1,r0,LSL #3
00002e  4902              LDR      r1,|L1.56|
000030  8008              STRH     r0,[r1,#0]
;;;17     }								    
000032  bd10              POP      {r4,pc}
;;;18     
                          ENDP

                  |L1.52|
                          DCD      fac_us
                  |L1.56|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=1

                  delay_ms PROC
;;;69     *******************************************************************************/
;;;70     void delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;71     {	 	 
000002  4604              MOV      r4,r0
;;;72     	u8 repeat=nms/540;		//这里用540,是考虑到某些客户可能超频使用,
000004  f44f7007          MOV      r0,#0x21c
000008  fb94f0f0          SDIV     r0,r4,r0
00000c  b2c6              UXTB     r6,r0
;;;73     							//比如超频到248M的时候,delay_nms最大只能延时541ms左右了
;;;74     	u16 remain=nms%540;
00000e  f44f7007          MOV      r0,#0x21c
000012  fb94f1f0          SDIV     r1,r4,r0
000016  fb004011          MLS      r0,r0,r1,r4
00001a  b285              UXTH     r5,r0
;;;75     	while(repeat)
00001c  e005              B        |L2.42|
                  |L2.30|
;;;76     	{
;;;77     		delay_nms(540);
00001e  f44f7007          MOV      r0,#0x21c
000022  f7fffffe          BL       delay_nms
;;;78     		repeat--;
000026  1e70              SUBS     r0,r6,#1
000028  b2c6              UXTB     r6,r0
                  |L2.42|
00002a  2e00              CMP      r6,#0                 ;75
00002c  d1f7              BNE      |L2.30|
;;;79     	}
;;;80     	if(remain)delay_nms(remain);
00002e  b115              CBZ      r5,|L2.54|
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       delay_nms
                  |L2.54|
;;;81     } 
000036  bd70              POP      {r4-r6,pc}
;;;82     
                          ENDP


                          AREA ||i.delay_nms||, CODE, READONLY, ALIGN=2

                  delay_nms PROC
;;;48     *******************************************************************************/
;;;49     void delay_nms(u16 nms)
000000  4601              MOV      r1,r0
;;;50     {	 		  	  
;;;51     	u32 temp;		   
;;;52     	SysTick->LOAD=(u32)nms*fac_ms;			//时间加载(SysTick->LOAD为24bit)
000002  4a11              LDR      r2,|L3.72|
000004  8812              LDRH     r2,[r2,#0]  ; fac_ms
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;53     	SysTick->VAL =0x00;           			//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;54     	SysTick->CTRL|=0x01 ; //开始倒数 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;55     	do
00001c  bf00              NOP      
                  |L3.30|
;;;56     	{
;;;57     		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;58     	}while((temp&0x01)&&!(temp&(1<<16)));	//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L3.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L3.30|
                  |L3.50|
;;;59     	SysTick->CTRL&=~0x01; //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;60     	SysTick->VAL =0X00;     		  		//清空计数器	  	    
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;61     }
000046  4770              BX       lr
;;;62     
                          ENDP

                  |L3.72|
                          DCD      fac_ms

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;25     *******************************************************************************/
;;;26     void delay_us(u32 nus)
000000  4601              MOV      r1,r0
;;;27     {		
;;;28     	u32 temp;	    	 
;;;29     	SysTick->LOAD=nus*fac_us; 				//时间加载	  		 
000002  4a11              LDR      r2,|L4.72|
000004  7812              LDRB     r2,[r2,#0]  ; fac_us
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;30     	SysTick->VAL=0x00;        				//清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;31     	SysTick->CTRL|=0x01 ; //开始倒数 	 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;32     	do
00001c  bf00              NOP      
                  |L4.30|
;;;33     	{
;;;34     		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;35     	}while((temp&0x01)&&!(temp&(1<<16)));	//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L4.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L4.30|
                  |L4.50|
;;;36     	SysTick->CTRL&=~0x01; //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;37     	SysTick->VAL =0X00;       				//清空计数器 
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;38     }
000046  4770              BX       lr
;;;39     
                          ENDP

                  |L4.72|
                          DCD      fac_us

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\systick\\systick.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_systick_c_6d17d239____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_systick_c_6d17d239____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_systick_c_6d17d239____REVSH|
#line 144
|__asm___9_systick_c_6d17d239____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_systick_c_6d17d239____RRX|
#line 300
|__asm___9_systick_c_6d17d239____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
